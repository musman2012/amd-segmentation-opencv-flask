# -*- coding: utf-8 -*-
"""OpenCV/RPEDots2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/168CfRCUW5Es5dU0thal_8etfA6XJ9wvw
"""

!pip install mat4py
import matplotlib.pyplot as plt
import numpy as np
import h5py
from mat4py import loadmat

#data = loadmat('/content/2macula.mat')

from google.colab import drive
drive.mount('/content/drive/')

import matplotlib.pyplot as plt
import numpy as np
import scipy.io as io
import matplotlib.image as mpimg
import cv2 as cv

#matfile = io.loadmat('/content/2macula.mat')

## This implementation is based on following research paper:
## https://www.longdom.org/open-access/contribution-to-intraretinal-fluid-segmentation-in-optical-coherence-tomography-by-using-automatic-personalized-thresholding-2155-9570-1000738.pdf

"""This code is an implementation of [this research paper](https://www.longdom.org/open-access/contribution-to-intraretinal-fluid-segmentation-in-optical-coherence-tomography-by-using-automatic-personalized-thresholding-2155-9570-1000738.pdf)"""

def show_img(img2show):
  fig = plt.figure(figsize=(5, 5))
  plt.imshow(img)
  plt.show()

## Apply denoising (Median Filters [23,24,37] )
## 3 × 3 pixels 
def apply_median_filter(in_img):
  filtered_img = cv.medianBlur(img, 3)
  #show_img(filtered_img)
  return filtered_img

## Apply K-Mean Clustering (Color Quantization)
def apply_k_mean_clustering(in_img):
  Z = in_img.reshape((-1,3))
  # convert to np.float32
  Z = np.float32(Z)
  # define criteria, number of clusters(K) and apply kmeans()
  criteria = (cv.TERM_CRITERIA_EPS + cv.TERM_CRITERIA_MAX_ITER, 10, 1.0)
  K = 2
  ret,label,center=cv.kmeans(Z,K,None,criteria,10,cv.KMEANS_RANDOM_CENTERS)
  # Now convert back into uint8, and make original image
  center = np.uint8(center)
  res = center[label.flatten()]
  res2 = res.reshape((in_img.shape))
  return res2
  #cv.imshow('res2',res2)
  #show_img(res2)
  #fig = plt.figure(figsize=(5, 5))
  #plt.imshow(res2)
  #plt.show()
  #cv.waitKey(0)
  #cv.destroyAllWindows()

### Apply Canny Edge Detector
def apply_canny_edge(in_img):
  edges = cv.Canny(in_img,50,200)

  return edges
  #fig = plt.figure(figsize=(5, 5))
  #plt.imshow(edges)
  #plt.show()

def find_high_intensity_areas(in_img, th):
  resultr, resultc = [], []
  rows, cols = in_img.shape
  for col in range(cols):
    for row in range(rows):
      if in_img[row, col] > th:
        #temp = (row, col)
        resultr.append(row)
        resultc.append(col)
      
  return (resultr, resultc)

## Detect position of ILM
def detect_ilm1(in_img):
  #print(edges.shape) ## 390, 508 ==> Rows x Cols
  rows, cols = in_img.shape
  center = cols//2
  center += 50
  c_flag = 0
  ilm_pos = []
  ilm_dict = dict()
  seg_img = np.zeros((rows, cols), np.uint8)
  prev_row = 0
  max_diff = 65
  for col in range(center, cols):
    for row in range(rows):
      c_flag = 0
      #if col == center:
      if in_img[row, col] > 200:
        for index in range(1, max_diff):
          temp_index = row + index
          if temp_index >= 390 or index == max_diff:
            #print("reached at the end")
            break
          if in_img[temp_index, col] > 200 and (abs(prev_row - temp_index) < 5 or prev_row == 0):
            #print("new layer detected")
            pos = (temp_index, col)
            ilm_dict[col] = temp_index
            ilm_pos.append(pos)
            prev_row = temp_index
            c_flag = 1
            break
        
        if c_flag == 0:
          if col in ilm_dict:
            break

          pos = (row, col)
          ilm_dict[col] = row
          ilm_pos.append(pos)
            #print("In the loop", row, col)
          prev_row = row
          break

        break
        '''
      if in_img[row, col] > 200 and (abs(prev_row - row) < 5 or prev_row == 0):
        seg_img[row, col] = 255
        pos = (row, col)
        ilm_dict[col] = row
        ilm_pos.append(pos)
        #print("In the loop", row, col)
        prev_row = row
        break
        '''

  prev_row = 0
  for col in range(center-1, -1, -1):
    for row in range(rows):
      if in_img[row, col] > 200 and (abs(prev_row - row) < 5 or prev_row == 0):
        seg_img[row, col] = 255
        pos = (row, col)
        ilm_pos.append(pos)
        ilm_dict[col] = row
        #print("In the loop", row, col)
        prev_row = row
        break
  
  
  return ilm_pos, ilm_dict
  #fig = plt.figure(figsize=(5, 5))
  #plt.imshow(seg_img)
  #plt.show()

## now we know that 
def find_RPE_col(rows, cols, in_loc):
  rpe_pos = []
  counter = 0

  for r in rows:
    if r == in_loc:
      break
    counter += 1

  return cols[counter]

## here we know the index of high intensity row

def detect_ilm(in_img):
  #print(edges.shape) ## 390, 508 ==> Rows x Cols
  rows, cols = in_img.shape
  center = cols//2
  center += 50
  ilm_pos = []
  ilm_dict = dict()
  seg_img = np.zeros((rows, cols), np.uint8)
  prev_row = 0
  for col in range(center, cols):
    for row in range(rows):
      if in_img[row, col] > 200 and (abs(prev_row - row) < 5 or prev_row == 0):
        seg_img[row, col] = 255
        pos = (row, col)
        ilm_dict[col] = row
        ilm_pos.append(pos)
        #print("In the loop", row, col)
        prev_row = row
        break

  prev_row = 0
  for col in range(center-1, -1, -1):
    for row in range(rows):
      if in_img[row, col] > 200 and (abs(prev_row - row) < 5 or prev_row == 0):
        seg_img[row, col] = 255
        pos = (row, col)
        ilm_pos.append(pos)
        ilm_dict[col] = row
        #print("In the loop", row, col)
        prev_row = row
        break
  
  
  return ilm_pos, ilm_dict

#(hi_rows, high_cols) = find_high_intensity_areas(gray)
#print(hi_rows.median())

#gray = cv.cvtColor(filtered_img, cv.COLOR_BGR2GRAY)
# perform a naive attempt to find the (x, y) coordinates of
# the area of the image with the largest intensity value
#(minVal, maxVal, minLoc, maxLoc) = cv.minMaxLoc(gray)
#cv.circle(img_ilm, maxLoc, 5, (255, 0, 0), 2)

def segment_rpe1(gray_img, rpe_col, rpe_row, t_cols):
  rpe_pos = []
  rpe_dict = dict()
  sliding_row = rpe_row
  temp1 = (sliding_row, rpe_col)
  max_rows, max_cols = gray_img.shape
  rpe_dict[rpe_col] = sliding_row
  rpe_pos.append(temp1)
  int_thr = 170
  prev_row2 = sliding_row
  prev_row1 = sliding_row
  ### Use these rows to track previous two values of rows
  ## next row should be prev_row1 + (prev_row1 - prev_row2)
  prev_pos_tracker = 0
  for c in range(rpe_col-1, 0, -1):
    
    for index in range(1, 10):
      flag = 0
      if sliding_row + index < max_rows:
        max_val  = gray_img[sliding_row+index, c]
        max_index = sliding_row + index
      

        if gray_img[sliding_row + index, c] > int_thr:
            if gray_img[sliding_row + index, c] > gray_img[sliding_row - index, c]:
              sliding_row += index
              temp = (sliding_row, c)
              rpe_dict[c] = sliding_row
              rpe_pos.append(temp)
              flag = 1
              break

      #if gray_img[sliding_row - index, c] > max_val:
       # max_val  = gray_img[sliding_row-index, c]
       # max_index = sliding_row - index

      if gray_img[sliding_row - index, c] > int_thr:
        sliding_row -= index
        temp = (sliding_row, c)
        rpe_dict[c] = sliding_row
        rpe_pos.append(temp)
        flag = 1
        break

    #if prev_pos_tracker % 3 == 1:
    
      
    #elif prev_pos_tracker % 3 == 2:
    prev_row2 = prev_row1
    prev_row1 = sliding_row

    

    if flag == 0:
      new_row = prev_row1 + (prev_row1 - prev_row2)
      temp = (new_row, c)
      rpe_dict[c] = new_row
      rpe_pos.append(temp)
      
  sliding_row = rpe_row
  prev_row2 = sliding_row
  prev_row1 = sliding_row
  for c in range(rpe_col, t_cols):
    for index in range(1, 10):
      '''
      if sliding_row + index < t_cols:
        val = gray_img[sliding_row + index, c]
        #print(val)
        if val > max_val:
          max_val = gray_img[sliding_row + index, c]
          max_index = sliding_row + index

      if sliding_row - index >= 0:
        val = gray_img[sliding_row - index, c]
        if gray_img[sliding_row - index, c] > max_val:
          max_val = gray_img[sliding_row - index, c]
          max_index = sliding_row - index
      '''
      flag = 0
      if sliding_row + index < max_rows:
        if gray_img[sliding_row + index, c] > int_thr:
          if gray_img[sliding_row + index, c] > gray_img[sliding_row - index, c]:
            sliding_row += index
            temp = (sliding_row, c)
            rpe_dict[c] = sliding_row
            rpe_pos.append(temp)
            flag = 1
            break

      elif gray_img[sliding_row - index, c] > int_thr:
        sliding_row -= index
        temp = (sliding_row, c)
        rpe_dict[c] = sliding_row
        rpe_pos.append(temp)
        flag = 1
        break

    prev_row2 = prev_row1
    prev_row1 = sliding_row

    if flag == 0:
      new_row = prev_row1 + (prev_row1 - prev_row2)
      temp = (new_row, c)
      rpe_dict[c] = new_row
      rpe_pos.append(temp)

      
  
  return rpe_pos, rpe_dict

def segment_rpe1(gray_img, rpe_col, rpe_row, t_cols):
  rpe_pos = []
  rpe_dict = dict()
  sliding_row = rpe_row
  temp1 = (sliding_row, rpe_col)
  rpe_dict[rpe_col] = sliding_row
  rpe_pos.append(temp1)
  int_thr = 170
  prev_row2 = sliding_row
  prev_row1 = sliding_row
  ### Use these rows to track previous two values of rows
  ## next row should be prev_row1 + (prev_row1 - prev_row2)
  prev_pos_tracker = 0
  for c in range(rpe_col-1, 0, -1):
    
    for index in range(1, 10):
      flag = 0
      max_val  = gray_img[sliding_row+index, c]
      max_index = sliding_row + index
      '''
      if sliding_row + index < t_cols:
        val = gray_img[sliding_row + index, c]
        print(val)
        if val > max_val:
          max_val = gray_img[sliding_row + index, c]
          max_index = sliding_row + index

      if sliding_row - index >= 0:
        val = gray_img[sliding_row - index, c]
        if gray_img[sliding_row - index, c] > max_val:
          max_val = gray_img[sliding_row - index, c]
          max_index = sliding_row - index
      
      
      temp = (max_index, c)
      rpe_dict[c] = max_index
      rpe_pos.append(temp)
      
      if gray_img[sliding_row + index, c] > max_val:
        max_val  = gray_img[sliding_row+index, c]
        max_index = sliding_row + index
      '''

      if gray_img[sliding_row + index, c] > int_thr:
        if gray_img[sliding_row + index, c] > gray_img[sliding_row - index, c]:
          sliding_row += index
          temp = (sliding_row, c)
          rpe_dict[c] = sliding_row
          rpe_pos.append(temp)
          flag = 1
          break

      #if gray_img[sliding_row - index, c] > max_val:
       # max_val  = gray_img[sliding_row-index, c]
       # max_index = sliding_row - index

      if gray_img[sliding_row - index, c] > int_thr:
        sliding_row -= index
        temp = (sliding_row, c)
        rpe_dict[c] = sliding_row
        rpe_pos.append(temp)
        flag = 1
        break

    #if prev_pos_tracker % 3 == 1:
    
      
    #elif prev_pos_tracker % 3 == 2:
    prev_row2 = prev_row1
    prev_row1 = sliding_row

    

    if flag == 0:
      new_row = prev_row1 + (prev_row1 - prev_row2)
      temp = (new_row, c)
      rpe_dict[c] = new_row
      rpe_pos.append(temp)
      
  sliding_row = rpe_row
  prev_row2 = sliding_row
  prev_row1 = sliding_row
  for c in range(rpe_col, t_cols):
    for index in range(1, 10):
      '''
      if sliding_row + index < t_cols:
        val = gray_img[sliding_row + index, c]
        #print(val)
        if val > max_val:
          max_val = gray_img[sliding_row + index, c]
          max_index = sliding_row + index

      if sliding_row - index >= 0:
        val = gray_img[sliding_row - index, c]
        if gray_img[sliding_row - index, c] > max_val:
          max_val = gray_img[sliding_row - index, c]
          max_index = sliding_row - index
      '''
      flag = 0
      if gray_img[sliding_row + index, c] > int_thr:
        if gray_img[sliding_row + index, c] > gray_img[sliding_row - index, c]:
          sliding_row += index
          temp = (sliding_row, c)
          rpe_dict[c] = sliding_row
          rpe_pos.append(temp)
          flag = 1
          break

      elif gray_img[sliding_row - index, c] > int_thr:
        sliding_row -= index
        temp = (sliding_row, c)
        rpe_dict[c] = sliding_row
        rpe_pos.append(temp)
        flag = 1
        break

    prev_row2 = prev_row1
    prev_row1 = sliding_row

    if flag == 0:
      new_row = prev_row1 + (prev_row1 - prev_row2)
      temp = (new_row, c)
      rpe_dict[c] = new_row
      rpe_pos.append(temp)

      
  
  return rpe_pos, rpe_dict

def return_avg(starting_index, col_val, hi_cols, hi_rows):
  counter = sum = 0
  while hi_cols[starting_index] == col_val:
    sum += hi_rows[starting_index]
    starting_index += 1
    counter += 1
    if starting_index < len(hi_cols):
      break

  return sum//counter, starting_index

def segment_rpe(hi_rows, hi_cols, size):
  rpe_pos = []
  rpe_dict = dict()
  c_index = 0
  col_ptr = 0
  prev_row = 0

  for c_index in range(0, size):
    #while high_cols[c_index] == c_index:
    while col_ptr < len(hi_cols) and hi_cols[col_ptr] == c_index:
      col_ptr += 1
    temp = hi_rows[col_ptr-1], c_index
    rpe_pos.append(temp)
    rpe_dict[c_index] = hi_rows[col_ptr-1]
    '''
    if col_ptr < len(hi_cols) and hi_cols[col_ptr] == c_index: ## this column has certain bright spots
      aveg, ending_index = return_avg(col_ptr, c_index, hi_cols, hi_rows)
      prev_row = aveg
    
    else:
      aveg = prev_row
      temp = aveg, c_index
      rpe_pos.append(temp)
      rpe_dict[c_index] = aveg
      col_ptr += 1
    '''
  return rpe_pos, rpe_dict

def estimate_rpe(bm_pos_curve, rpe_pos_curve, total_cols):
  segmented_pos = []
  pos_dict = dict()
  for counter in range(0,76):
    bmr, bmc = bm_pos_curve[counter]
    rper, rpec = rpe_pos_curve[counter]
    tr = min(bmr, rper) 
    temp = tr, counter #bm_pos_curve[counter]
    segmented_pos.append(temp)
    pos_dict[counter] = tr

  for counter in range(76, 326):
    temp = rpe_pos_curve[counter]
    tr, tc = temp
    segmented_pos.append(temp)
    pos_dict[counter] = tr

  for counter in range(326, total_cols):
    temp = bm_pos_curve[counter]
    tr, tc = temp
    segmented_pos.append(temp)
    pos_dict[counter] = tr

  #counter = 350

  ## starting from this counter:
  ## Phase-I ==> replace rpe pos with bm_pos_curve
  ## Plus do the same for first 50 cols
  ##########################################
  ## Phase-II ==> Check the difference in both curves and make decision

  #r,c = bm_pos_curve[counter]

  #print("Row col", r, c)

  return segmented_pos, pos_dict

def find_starting_row_fluid(ilm_dict, counter):
  if counter in ilm_dict:
      starting_row = ilm_dict[counter] + 15
      return starting_row
  else:
    for i in range(10):
      if counter-i in ilm_dict:
        starting_row = ilm_dict[counter-i]
        return starting_row

      elif counter+i in ilm_dict:
        starting_row = ilm_dict[counter+i]
        return starting_row

  return -999



def find_ending_row_fluid(rpe_dict, counter):
  if counter in rpe_dict:
      starting_row = rpe_dict[counter]
      return starting_row
  else:
    for i in range(150):
      if counter-i in rpe_dict:
        starting_row = rpe_dict[counter-i]
        return starting_row

      elif counter+i in rpe_dict:
        starting_row = rpe_dict[counter+i]
        return starting_row

  return -99

def seg_fluid(gray_img, ilm_pos, rpe_pos, thershld, thershld2, ilm_dict, rpe_dict):
  ## length of rows should be equal to number of cols
  ilm_rows, ilm_cols, rpe_rows, rpe_cols = [],[],[],[]
  MAX_ROW, MIN_ROW = 0,0
  NUM_ROWS, NUM_COLS = gray_img.shape
  fluid_pos = []

  for ilms in ilm_pos:
    (row, col) = ilms
    ilm_rows.append(row)
    ilm_cols.append(col)

  for rpes in rpe_pos:
    (row, col) = rpes
    rpe_rows.append(row)
    rpe_cols.append(col)

  MAX_ROW = max(rpe_rows)
  MIN_ROW = min(ilm_rows)

 # print(len(ilm_rows))
  #print(gray_img.shape)

  counter = -1
  prev_ending_row = MAX_ROW
  prev_starting_row = MIN_ROW

  for c in range(NUM_COLS):
    counter += 1
    starting_row = find_starting_row_fluid(ilm_dict, counter)
    ending_row = find_ending_row_fluid(rpe_dict, counter)
    #print("Ending nrw", ending_row, counter, NUM_COLS)
    if ending_row == -99 or ending_row is None:
      ending_row = prev_ending_row

    if starting_row == -999:
      starting_row = prev_starting_row
      
    while starting_row <= ending_row:
    #for r in range(starting_row, MAX_ROW):  ## TODO-2 MAKE IT DEPENDENT ON RPE VAL HERE
      #print("Starting row is",starting_row)
      r = starting_row
      if gray_img[r, c] > thershld and gray_img[r, c] < thershld2:
        temp = (r, c)
        #resultr.append(row)
        fluid_pos.append(temp)
      starting_row += 1
    prev_ending_row = ending_row
    prev_starting_row = starting_row

  return fluid_pos, MAX_ROW, MIN_ROW

def seg_fluid1(gray_img, ilm_pos, rpe_pos, thershld, thershld2, ilm_dict, rpe_dict):
  ## length of rows should be equal to number of cols
  ilm_rows, ilm_cols, rpe_rows, rpe_cols = [],[],[],[]
  MAX_ROW, MIN_ROW = 0,0
  NUM_ROWS, NUM_COLS = gray_img.shape
  fluid_pos = []

    for c in range(NUM_COLS):
    counter += 1
    starting_row = find_starting_row_fluid(ilm_dict, counter)
    ending_row = find_ending_row_fluid(rpe_dict, counter)
    #print("Ending nrw", ending_row, counter, NUM_COLS)
    if ending_row == -99 or ending_row is None:
      ending_row = prev_ending_row

    if starting_row == -999:
      starting_row = prev_starting_row
      
    while starting_row <= ending_row:
    #for r in range(starting_row, MAX_ROW):  ## TODO-2 MAKE IT DEPENDENT ON RPE VAL HERE
      r = starting_row
      if gray_img[r, c] > thershld and gray_img[r, c] < thershld2:
        temp = (r, c)
        #resultr.append(row)
        fluid_pos.append(temp)
      starting_row += 1
    prev_ending_row = ending_row
    prev_starting_row = starting_row




  return fluid_pos

def remove_intensity_outliers1(ilm_mode, ilm_dict, hi_r, hi_c):
  new_rows, new_cols = [],[]
  index = 0
  PIXEL_DIFF_TH, th2 = 35, 20
  IMP_COL = 100
  #print("ILM MODE ", ilm_mode)
  '''
  for c in hi_c:
    ## in each column, remove two outliers
    ## (i) values above ilm
    ## (ii) values 30 pixel under that point
    if index in ilm_dict:
      if ilm_dict[index] > hi_r[index]:
        continue

      #if abs(ilm_dict[index] - hi_r[index]) < 30:
       # continue

      new_rows.append(c)
      new_cols.append(hi_r[index])


  '''
  for r in hi_r:
    
    if index > len(hi_c):
      continue

    if IMP_COL in ilm_dict:
      if abs(r - ilm_dict[IMP_COL]) < th2:
        continue
    #if index in ilm_dict:
     # print("Row from intensity , ILM and Column", r, ilm_dict[index], index)
      #if r > ilm_dict[index] or abs(r-ilm_dict[index]) < 40:
       # continue

    if abs(r - ilm_mode) > PIXEL_DIFF_TH:
      new_rows.append(r)
      new_cols.append(hi_c[index])

    index += 1
    

  return new_rows, new_cols

def remove_extremes(new_rows, new_cols):
  rows, cols = [], []
  r_mode = stats.mode(new_rows)
  r_mode = r_mode[0][0]

  for i in range(0, len(new_rows)):
    if r_mode - new_rows[i] > 70:
      continue
    rows.append(new_rows[i])
    cols.append(new_cols[i])
  
  return rows, cols

def remove_intensity_outliers(ilm_mode, ilm_dict, hi_r, hi_c):
  new_rows, new_cols = [],[]
  #index = 0
  PIXEL_DIFF_TH, th2 = 50, 20
  IMP_COL = 100

  for index in range(0, len(hi_r)):
    c = hi_c[index]
    r = hi_r[index]
    flag = 0
    #print(c,r)
    if c in ilm_dict:
      if (r - ilm_dict[c]) < PIXEL_DIFF_TH:
        flag = 1
    else:
      for i in range(1,6):
        new_c = index + i
        if new_c in ilm_dict:
          if (r - ilm_dict[new_c]) < PIXEL_DIFF_TH:
            flag = 1

        new_c = index - i
        if new_c in ilm_dict:
          if (r - ilm_dict[new_c]) < PIXEL_DIFF_TH:
            flag = 1
    
    if flag == 1:
      continue
        
    #print("Vals appended", index)
    new_rows.append(r)
    new_cols.append(c)
    
#   index += 1

  new_rows, new_cols = remove_extremes(new_rows, new_cols)

  return (new_rows, new_cols)

from scipy import stats

def return_vals(my_dict):
  vals = []
  for key in my_dict:
    vals.append(my_dict[key])

  return vals

from collections import Counter 

def estimate_rpe1(new_hi_rows, new_hi_cols, rpe_col):
  r_mode = stats.mode(new_hi_rows)
  countes = Counter(new_hi_rows) 
  second_frq = countes.most_common(2)[0][0]
  r_mode = r_mode[0][0]
  s_index = 0
  prev1, prev2 = 0,0
  for r in new_hi_rows:
    if r == second_frq:
      break
    s_index += 1

  last = len(new_hi_cols) - 1
  second = max(rpe_col, s_index)
  first = min(rpe_col, s_index)
  
  ## last part
  prev2 = new_hi_rows[second]
  prev1 = new_hi_rows[second + 1] ## moving to the right first

  

  ## now we know the index from where to start
  for i in range(second+2, ):
    if abs(prev1 - new_hi_rows[i]) > 10:  ## outlier
      new_hi_rows[i] = prev1 + (prev2 - prev1)
    prev2 = prev1
    prev1 = new_hi_rows[i]

  ## second last

  prev2 = new_hi_rows[second]
  prev1 = new_hi_rows[second - 1] ## moving to left

  for i in range(second-2, first-1, -1):
    if abs(prev1 - new_hi_rows[i]) > 10:  ## outlier
      new_hi_rows[i] = prev1 + (prev2 - prev1)
    prev2 = prev1
    prev1 = new_hi_rows[i]

  ## first part

  prev2 = new_hi_rows[first]
  prev1 = new_hi_rows[first - 1] ## moving to left

  for i in range(first-2, -1, -1):
    if abs(prev1 - new_hi_rows[i]) > 10:  ## outlier
      new_hi_rows[i] = prev1 + (prev2 - prev1)
    prev2 = prev1
    prev1 = new_hi_rows[i]



  return new_hi_rows, new_hi_cols

def seg_foci(gray_img, thershld_min, thershld_max, ilm_dict, rpe_dict, MAX_ROW, MIN_ROW, RPE_ROW):
  ## length of rows should be equal to number of cols

  ## another algorithm
  ## detect the bright clusters (Spots) first
  ## pick those clusters having area of less than ___
  ## only those which are below ILM and above RPE
  
  NUM_ROWS, NUM_COLS = gray_img.shape
  foci_pos = []

  #print("rows and cols are ", NUM_ROWS, NUM_COLS)
  
  counter = -1
  prev_ending_row = MAX_ROW
  prev_starting_row = MIN_ROW

  ending_row = prev_ending_row

  for c in range(NUM_COLS):
    counter += 1
    starting_row = find_starting_row_fluid(ilm_dict, counter)
    ending_row = find_ending_row_fluid(rpe_dict, counter)
    #print("Ending nrw", ending_row, counter, NUM_COLS)
    #if ending_row == -99 or ending_row is None:
    ##  ending_row = prev_ending_row

    if starting_row == -999:
      starting_row = prev_starting_row

    starting_row += 20
    ending_row -= 20
      
    while starting_row <= ending_row and starting_row < NUM_ROWS:
    #for r in range(starting_row, MAX_ROW):  ## TODO-2 MAKE IT DEPENDENT ON RPE VAL HERE
      #print("Starting row is",starting_row)
      r = starting_row
      #if abs(r - RPE_ROW) < 10:
      #  continue
      
      if gray_img[r, c] > thershld_min and gray_img[r, c] < thershld_max:
        temp = (r, c)
        #resultr.append(row)
        foci_pos.append(temp)
      starting_row += 1
    prev_ending_row = ending_row
    prev_starting_row = starting_row

  return foci_pos

def cluster_fluid_edges(edges_img, segmented_rpe_dict, ilm_dict):
  empty_img = np.zeros((gray.shape[0], gray.shape[1]), np.uint8)
  t_cols = len(segmented_rpe_dict)
  #print("total cols are ", t_cols, len(segmented_rpe_dict))
  center = t_cols // 2
  lower_bound = 15
  p_start_row, p_end_row = ilm_dict[center], segmented_rpe_dict[center]
  for c in range(center-1, -1, -1):
    start_row = p_start_row
    end_row = p_end_row
    if c in ilm_dict:
      start_row = ilm_dict[c]
    end_row = segmented_rpe_dict[c]
    empty_img[start_row + 5: end_row+lower_bound, c] = edges_img[start_row + 5: end_row+lower_bound, c]
    p_start_row = start_row
    p_end_row = end_row

  for c in range(center+1, t_cols):
    start_row = p_start_row
    end_row = p_end_row
    if c in ilm_dict:
      start_row = ilm_dict[c]
    end_row = segmented_rpe_dict[c]
    empty_img[start_row + 5: end_row+lower_bound, c] = edges_img[start_row + 5: end_row+lower_bound, c]
    p_start_row = start_row
    p_end_row = end_row

  #for val in segmented_rpe_dict:
   # empty_img[segmented_rpe_dict[val], val] = 255

  return empty_img

def locate_fluid_from_clusters(fluid_clus, segmented_rpe_dict):
  new_fluid_pos = []
  t_rows, t_cols = fluid_clus.shape
  min_row = 100
  max_row = t_rows
  #t_cols = len(segmented_rpe_dict)
  for c in range(0, t_cols):
    max_row = segmented_rpe_dict[c]
    for r in range(min_row, t_rows):
      if fluid_clus[r,c] > 100:     ## starting row detected
        temp = (r,c)
        new_fluid_pos.append(temp)
        counter = 1
        while ((r+counter) < max_row) and fluid_clus[r+counter,c] < 100:
           temp = (r+counter,c)
           new_fluid_pos.append(temp)
           counter += 1
        break

  return new_fluid_pos

pip install python-docx     ## would only be needed if the output has to be in a docx file

def abrupt_change_fluid(gray, foci_mn_th, foci_mx_th, ilm_dict, segmented_rpe_dict, mx_row, mn_row, rpe_row):
  t_cols = gray.shape[1]
  temp_f_pos = []
  for col in range(0, t_cols):
    min_row = mn_row
    max_row = mx_row
    if col in ilm_dict:
      min_row = ilm_dict[col]
    if col in rpe_dict:
      max_row = rpe_dict[col]

    row = min_row + 10
    prev_val = gray[row,col]
    while row < max_row:
      if abs(gray[row,col] - prev_val) > 250:
        temp = (row,col)
        temp_f_pos.append(temp)
      prev_val = gray[row,col]
      row += 5

  return temp_f_pos
  ### start from the ILM pos
  ### Go until RPE
  ## See if the difference is more than a specific value
  ## add to list

def fluid_clustering(in_img):
  Z = in_img.reshape((-1,3))
  # convert to np.float32
  Z = np.float32(Z)
  # define criteria, number of clusters(K) and apply kmeans()
  criteria = (cv.TERM_CRITERIA_EPS + cv.TERM_CRITERIA_MAX_ITER, 10, 1.0)
  K = 3
  ret,label,center=cv.kmeans(Z,K,None,criteria,100,cv.KMEANS_RANDOM_CENTERS)
  # Now convert back into uint8, and make original image
  center = np.uint8(center)
  res = center[label.flatten()]
  res2 = res.reshape((in_img.shape))
  return res2

def find_ret_contours(gray):
  rows, cols = gray.shape
  out_img = md_img.copy()
  contours, hierarchy = cv.findContours(gray, cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE)
  areas = []
  for cntr in contours:
    flag = 1
    area = cv.contourArea(cntr)
    areas.append(area)
    # for tpl in cntr:
    #   if 0 in tpl or rows-1 in tpl:
    #     flag = 0
    #     break
    if area < 200 or area > 200:
      #eps = 0.01 * cv.arcLength(cntr, True)
      #approx = cv.approxPolyDP(cntr, eps, True)
      out_img = cv.drawContours(out_img, [cntr], 0, (0,255,0), 3) ## -1 indicates drawing ALL, then the color

  return out_img, areas

def detect_roi(gray_th, ilm_pos, rpe_pos, ilm_dict, bm_pos_curve_dict):
  ilm_rows, rpe_rows = [],[]
  MAX_ROW, MIN_ROW = 0,0
  ROI = np.ones(gray_th.shape, np.uint8)
  NUM_COLS = gray_th.shape[1]

  for ilms in ilm_pos:
    (row, col) = ilms
    ilm_rows.append(row)

  for rpes in rpe_pos:
    (row, col) = rpes
    rpe_rows.append(row)

  MAX_ROW = max(rpe_rows)
  MIN_ROW = min(ilm_rows)
  
  for c in range(0, NUM_COLS):
    if c in ilm_dict:
      MIN_ROW = ilm_dict[c]

    if c in rpe_dict:
      MAX_ROW = rpe_dict[c]
    
    ROI[MIN_ROW+5:MAX_ROW, c] = gray_th[MIN_ROW+5:MAX_ROW, c]

  
  return ROI

import os
import docx


#from scipy.interpolate import spline
from scipy.interpolate import interp1d
from sklearn.linear_model import LogisticRegression

MIN_ROW = 10
MAX_ROW = 400

mydoc = docx.Document()

os.chdir('/content/drive/My Drive/Colab Notebooks/AMD/Cropped/')
#os.chdir('/content/drive/My Drive/Colab Notebooks/AMD/Data')
image_files = os.listdir()
MICRO_PER_PIXEL = 5.7
#os.chdir('/content/drive/My Drive/Colab Notebooks/AMD/Cropped_Data/')
#for img_name in image_files:
#img_name = image_files[25]
#img = img[MIN_ROW:MAX_ROW,500:,:]
#new_name = 'cropped_'+img_name
#cv.imwrite(new_name, img)

### THE PROBLEM IS WITH DETECTION OF ILM ---> FIX THAT --> OUTLIERS ARE BEING MARKED
for img_name in image_files:
  # img = cv.imread(img_name)
  # img = img[MIN_ROW:MAX_ROW,500:,:]
  # new_name = 'cropped_'+img_name
  # new_path = '/content/drive/My Drive/Colab Notebooks/AMD/Cropped/'+new_name
  # cv.imwrite(new_path, img)
  # continue
  
  ############ TASKS TO DO TUESDAY ############ 
  FLUID_THR = 75      ## TODO1: Make this adaptive with the intensity of scan higher value more FP
  ### TODO2: Separate out ROI (Region of Interest) + Add a Vertical line at left ==> Ignore open Contours
  ## Not having a line at the right would help us to avoid those crocodiles

  min_thrshld, max_thrshld = 0, 65 #65 ## TODO-1 MAKE THESE INTENSITIES DYNAMIC
  NUM_FLUID_PIXELS = NUM_FOCI_PIXELS = NUM_PED_PIXELS = 0
  RANGE_THRESHOLD = 145
  foci_mn_th, foci_mx_th = 210, 255
  RPE_THR = 200
  #img_name = image_files[9]
  #img_name = 'cropped_JB011.bmp'

  img = cv.imread(img_name)
  #img = resize_img(img)
  md_img = apply_median_filter(img)
  
  clus_img = apply_k_mean_clustering(md_img)
  kernel = np.ones((5,5),np.uint8)
  erosion = cv.erode(clus_img, kernel,iterations = 1)
  erosion = cv.morphologyEx(clus_img, cv.MORPH_CLOSE, kernel)
  erosion = cv.dilate(erosion, kernel,iterations = 1)

  ed_img = apply_canny_edge(erosion)
  ilm_pos, ilm_dict = detect_ilm(ed_img)
  #dilated_fluid = cv.dilate(erosion, kernel,iterations = 1)
  #dilated_fluid = apply_k_mean_clustering(dilated_fluid)
  ##fluid_fuzzy_clusters = fluid_clustering(md_img)
  
  #dbl_dil_edg = apply_canny_edge(dilated_fluid)
  #print("ILM Positions length is ", len(ilm_pos))
  #print("Length of ILM Dict", len(ilm_dict), ed_img.shape)
  #print("Length is ", len(ilm_dict), img_name)

  ########### DEBUGGING BLOCK ###########
  
  # fig = plt.figure(figsize=(15, 15))
  # ax = fig.add_subplot(1, 2, 1)
  # plt.imshow(img)
  # ax = fig.add_subplot(1, 2, 2)
  # plt.imshow(out_img)
  # plt.show()
  # #break
  # continue

  ########### DEBUGGING BLOCK ###########
  
  ## detecting RPE
  gray = cv.cvtColor(md_img, cv.COLOR_BGR2GRAY)
  vals = return_vals(ilm_dict)
  ilm_mode = stats.mode(vals)
  ilm_mode = ilm_mode[0][0]
  #print("ILM MODE VALS ",ilm_mode)
  #print(np.mean(gray))
  if np.mean(gray) < 51:
    RPE_THR -= 20
    max_thrshld -= 10
  if np.mean(gray) < 43:
    RPE_THR -= 20
    max_thrshld -= 10
  #print(np.mean(gray), RPE_THR, max_thrshld)
  (hi_rows, high_cols) = find_high_intensity_areas(gray, RPE_THR)
  #print("RPE VALS ",hi_rows)
  #print(ilm_mode)
  #print(ilm_dict)
  #print(len(ilm_dict))
  #print(len(hi_rows)) 
  #print(len(high_cols))
  #print(high_cols)

  total_bright_points = len(hi_rows)

  (hi_rows, high_cols) = remove_intensity_outliers(ilm_mode, ilm_dict, hi_rows, high_cols)
  '''
  rpe_func = interp1d(high_cols, hi_rows, fill_value='extrapolate', kind='cubic')
  new_hi_rows, new_hi_cols = [],[]
  print("Shape of gray ", gray.shape)
  for c in range(0, gray.shape[1]-1):
    print("X NEw is ", c)
    r = rpe_func(c)
    new_hi_rows.append(r)
    new_hi_cols.append(c)
  '''

  

  T_COLS = gray.shape[1]
  mode = stats.mode(hi_rows)
  rpe_row = mode[0][0]
  #print("RPE Rows and Cols are", len(hi_rows), len(high_cols))
  rpe_col = find_RPE_col(hi_rows, high_cols, rpe_row) 
  #f2 = interp1d(x, y, kind='cubic')
  #print("Size of image is ", gray.shape[1])
  rpe_pos, rpe_dict = segment_rpe(hi_rows, high_cols, gray.shape[1])

  new_hi_rows, new_hi_cols = [],[]
  
  for pos in rpe_pos:
    r,c = pos
    new_hi_rows.append(r)
    new_hi_cols.append(c)


  rpe_pos = []
  #rpe_dict = dict()
  for i in range(0, len(high_cols)):
    temp = hi_rows[i], high_cols[i]
    rpe_pos.append(temp)

  ############ The idea of applying a ploynominal fit was taken from 
  ### Automated Segmentation of RPE Layer for the
  ### Detection of Age Macular Degeneration Using OCT
  ### Images

  z = np.polyfit(high_cols, hi_rows, 15)      ## need to use this for Foci segmentation
  bm = np.polyfit(high_cols, hi_rows, 3)      ## need to use this for fluid segmentation
  second = np.polyfit(high_cols, hi_rows, 2)      ## second order
  ft_or = np.polyfit(high_cols, hi_rows, 5)
  rpe_equation = np.poly1d(z)
  bm_equation = np.poly1d(bm)
  fo_equation = np.poly1d(ft_or)
  so_equation = np.poly1d(second)

  rpe_pos_curve = []
  rpe_pos_curve_dict = dict()                 ## pass this dict to Foci segmentation
  #rpe_dict = dict()
  for i in range(0, T_COLS):
    curve_row = int(rpe_equation(i))
    temp = curve_row, i
    rpe_pos_curve.append(temp)
    rpe_pos_curve_dict[i] = curve_row

  bm_pos_curve = []
  bm_pos_curve_dict = dict()                  ## pass this dict to Fluid segmentation
  #rpe_dict = dict()
  for i in range(0, T_COLS):
    bm_row = int(bm_equation(i))
    temp = bm_row, i
    bm_pos_curve.append(temp)
    bm_pos_curve_dict[i] = bm_row

  fo_pos_curve = []
  fo_pos_curve_dict = dict()
  #rpe_dict = dict()
  for i in range(0, T_COLS):
    fo_row = int(fo_equation(i))
    temp = fo_row, i
    fo_pos_curve.append(temp)
    fo_pos_curve_dict[i] = fo_row

  so_pos_curve = []
  so_pos_curve_dict = dict()
  #rpe_dict = dict()
  for i in range(0, T_COLS):
    so_row = int(so_equation(i))
    temp = so_row, i
    so_pos_curve.append(temp)
    so_pos_curve_dict[i] = so_row

  #print("Size of dictionaries ", len(fo_pos_curve_dict), len(bm_pos_curve_dict), len(rpe_pos_curve_dict))


  ## This estimate function is taking bright points and returning average of it ==> Line Curve
  #(new_hi_rows, new_hi_cols) = estimate_rpe(new_hi_rows, new_hi_cols, rpe_col)

  '''
  new_rpe_pos = []
  new_rpe_dict = dict()
  for i in range(T_COLS-1):
    #print("Col and Predicted Row", i, row_new)
    row_new = new_hi_rows[i]
    col_new = new_hi_cols[i]
    temp = (row_new, col_new)
    new_rpe_pos.append(temp)
    new_rpe_dict[col_new] = row_new
  '''
  #rpe_pos, rpe_dict = segment_rpe(gray, rpe_col, rpe_row, gray.shape[1])
  #print(rpe_dict)

  segmented_rpe_pos, segmented_rpe_dict = estimate_rpe(bm_pos_curve, rpe_pos_curve, T_COLS)
  

  ## detecting Fluid
  roi = detect_roi(md_img, ilm_pos, rpe_pos, ilm_dict, segmented_rpe_dict)
  ret, thresh1 = cv.threshold(roi,FLUID_THR,255,cv.THRESH_BINARY_INV)
  gray_th = cv.cvtColor(thresh1, cv.COLOR_BGR2GRAY)
  out_img, areas = find_ret_contours(gray_th)
  print(areas)

  
  #print("Upper and lower bound ", min(ilm_pos))
  #fluid_clus = cluster_fluid_edges(dbl_dil_edg, segmented_rpe_dict, ilm_dict)  ## WRITE THIS FUNC

  ########### DEBUGGING BLOCK ###########
  fig = plt.figure(figsize=(15, 15))
  ax = fig.add_subplot(1, 2, 1)
  plt.imshow(img)
  ax = fig.add_subplot(1, 2, 2)
  plt.imshow(out_img)
  plt.show()
  #break
  continue

  ########### DEBUGGING BLOCK ###########

  new_fluid_pos = locate_fluid_from_clusters(fluid_clus, segmented_rpe_dict)

  
  

  #print(rpe_dict.keys())
  #print("Length of RPE Dict is ",len(rpe_dict))
  #print(rpe_pos)

  mid_dst = 89
  if 100 in ilm_dict:
    mid_dst = so_pos_curve_dict[100] - ilm_dict[100]


  new_dst = return_dist(ilm_dict, so_pos_curve_dict)

  if mid_dst < 100:
    max_thrshld -= 15

#  if 100 > mid_dst >= 90:
#    max_thrshld = 85

  fluid_pos, mx_row, mn_row = seg_fluid(gray, ilm_pos, rpe_pos, min_thrshld, max_thrshld, ilm_dict, bm_pos_curve_dict)

  foci_pos = seg_foci(gray, foci_mn_th, foci_mx_th, ilm_dict, segmented_rpe_dict, mx_row, mn_row, rpe_row)

  t_fluid = abrupt_change_fluid(gray, foci_mn_th, foci_mx_th, ilm_dict, segmented_rpe_dict, mx_row, mn_row, rpe_row)

  #count, th = 1, 10
  segmented_scan_ilm_rpe_final = img.copy()

  line_dst = return_dist(rpe_pos_curve_dict, so_pos_curve_dict)

  print("Lines distance is ", line_dst, " Brights spots", total_bright_points, "another", mid_dst)

  so_pos_curve_dict, so_pos_curve = adjust_bm(line_dst, so_pos_curve_dict, so_pos_curve)

  ped_pos = seg_ped(gray, so_pos_curve_dict, segmented_rpe_dict)

  if 2100 > new_dst > 50:
    fluid_pos = []

  TWO = 2
  ZERO = 0

  for ilm_position in ilm_pos:
    (row, col) = ilm_position
    segmented_scan_ilm_rpe_final[row:row+5, col, ZERO] = 240
    segmented_scan_ilm_rpe_final[row:row+5, col, 1] = 10
    segmented_scan_ilm_rpe_final[row:row+5, col, TWO] = 10


  for f in t_fluid:
    NUM_FLUID_PIXELS += 1
    (row_f, col_f) = f
    segmented_scan_ilm_rpe_final[row_f:row_f+1, col_f, TWO] = 20
    segmented_scan_ilm_rpe_final[row_f:row_f+1, col_f, 1] = 140
    segmented_scan_ilm_rpe_final[row_f:row_f+1, col_f, ZERO] = 240

  for rpe_position in segmented_rpe_pos:
    (row_r, col_r) = rpe_position
    segmented_scan_ilm_rpe_final[row_r:row_r+5, col_r, 1] = 245
    segmented_scan_ilm_rpe_final[row_r:row_r+5, col_r, ZERO] = 20
    segmented_scan_ilm_rpe_final[row_r:row_r+5, col_r, TWO] = 20
    #segmented_scan_ilm_rpe_final[row_r+1, col_r, 1] = 255
    #segmented_scan_ilm_rpe_final[row_r+2, col_r, 1] = 255
    #segmented_scan_ilm_rpe_final[row_r+3, col_r, 1] = 255
    #segmented_scan_ilm_rpe_final[row_r+4, col_r, 1] = 255

  
  for bm_position in ped_pos:
    NUM_PED_PIXELS += 1
    (row_r, col_r) = bm_position
    segmented_scan_ilm_rpe_final[row_r:row_r+3, col_r, 1] = 255
    segmented_scan_ilm_rpe_final[row_r:row_r+3, col_r, ZERO] = 255
    segmented_scan_ilm_rpe_final[row_r:row_r+3, col_r, TWO] = 10
  

  for fc in foci_pos:
    NUM_FOCI_PIXELS += 1
    (row_r, col_r) = fc
    segmented_scan_ilm_rpe_final[row_r:row_r+5, col_r, 1] = 64
    segmented_scan_ilm_rpe_final[row_r:row_r+5, col_r, ZERO] = 235
    segmented_scan_ilm_rpe_final[row_r:row_r+5, col_r, TWO] = 230

  fig = plt.figure(figsize=(5, 5))

  plt.imshow(segmented_scan_ilm_rpe_final)
  plt.show()

  temp_edges = apply_canny_edge(apply_median_filter(segmented_scan_ilm_rpe_final))
  plt.imshow(temp_edges)
  plt.show()

  quant_str = ""

  if NUM_FLUID_PIXELS > 10:
    quant_str += "Retinal Fluid Detected Area (µm) : "
    quant_str += str(round(NUM_FLUID_PIXELS * MICRO_PER_PIXEL, 3))
    quant_str += "\n\n"

    print("Retinal Fluid Detected Area (µm) :", round(NUM_FLUID_PIXELS * MICRO_PER_PIXEL, 3))

  else:
    quant_str += "No Retinal Fluid Detected in the Scan."
    quant_str += "\n\n"

  if NUM_FOCI_PIXELS > 0:
    quant_str += "Foci Detected Area (µm) : "
    quant_str += str(round(NUM_FOCI_PIXELS * MICRO_PER_PIXEL, 3))
    quant_str += "\n\n"

    print("Foci Detected Area (µm) :", NUM_FOCI_PIXELS * MICRO_PER_PIXEL)

  else:
    quant_str +=  "No Foci Detected in the Scan."
    quant_str += "\n\n"

  if NUM_PED_PIXELS > 0:
    quant_str += "PED Detected Area (µm) : "
    quant_str += str(round(NUM_PED_PIXELS * MICRO_PER_PIXEL, 3))
    quant_str += "\n\n"

    print("PED Detected Area (µm) :", NUM_PED_PIXELS * MICRO_PER_PIXEL)

  else:
    quant_str +=  "No Detachment in Pigment Epithelium."
    quant_str += "\n\n"

  # temp_img_path = "/content/"
  # temp_img_path += img_name
  # output_file_path = "/content/drive/My Drive/Colab Notebooks/AMD/Results"

  # cv.imwrite(temp_img_path, segmented_scan_ilm_rpe_final)

  # mydoc.add_heading(img_name, 2)
  # input_img = '/content/drive/My Drive/Colab Notebooks/AMD/Cropped/'+img_name
  # mydoc.add_picture(input_img, width=docx.shared.Inches(4), height=docx.shared.Inches(3))
  # mydoc.add_picture(temp_img_path, width=docx.shared.Inches(4), height=docx.shared.Inches(3))
  # mydoc.save("/content/drive/My Drive/Colab Notebooks/AMD/Segmentation_Quant_Res.docx")

  # mydoc.add_paragraph(quant_str)
  # mydoc.save("/content/drive/My Drive/Colab Notebooks/AMD/Segmentation_Quant_Res.docx")

  #cv.imread(img_name)
  #cv.imwrite(output_file_path, segmented_scan_ilm_rpe_final)

  break

## calculate the distance between yellow and green lines
## if its more than a specific threshold ==> Make the yellow line a bit (10 rows) down 
def return_dist(first_line_dict, second_line_dict):
  length = len(first_line_dict)
  distance = 0
  for i in range(100, length - 100, 10):
    if i in second_line_dict and i in first_line_dict:
      distance += abs(first_line_dict[i] - second_line_dict[i])

  return distance

def adjust_bm(distance, so_pos_curve_dict, so_pos_curve):
  residue = 0
  length = len(so_pos_curve_dict)
  # if distance > 300: ##
  #   residue += 10

  # if distance > 150: ##
  #   residue += 20

  # if distance > 800:
  #   residue -= 30

  for i in range(100, length - 100):
    so_pos_curve_dict[i] += residue
    temp = (so_pos_curve_dict[i], i)
    so_pos_curve[i] = temp
    #distance += abs(first_line_dict[i] - second_line_dict[i])

  return so_pos_curve_dict, so_pos_curve

def seg_ped(gray, so_pos_curve_dict, segmented_rpe_dict):
  length = len(so_pos_curve_dict)
  thresold = 130
  ped_rows = []
  ped_pos = []
  
  #ped_dict = dict()

  for c in range(100, length - 100):
    for r in range(segmented_rpe_dict[c], so_pos_curve_dict[c]):
      if gray[r,c] < thresold:
        temp = (r,c)
        ped_pos.append(temp)
        ped_rows.append(r)
        #ped_dict[c] = 
    
    #temp = (so_pos_curve_dict[i], i)
    #so_pos_curve[i] = temp


  return ped_pos

def resize_img(in_img):
  scale_percent = 30 # percent of original size
  width = int(img.shape[1] * scale_percent / 100)
  height = int(img.shape[0] * scale_percent / 100)
  new_dim = (width, height)

  resized = cv.resize(in_img, new_dim, interpolation = cv.INTER_AREA)

  return resized

